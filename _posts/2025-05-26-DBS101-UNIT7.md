---
title: DBS101 Unit 7
categories: [DBS101, Unit7]
tags: [DBS101]
---

## Before Learning
---
Before starting Unit 7, I had a surface-level understanding of transactions—mainly that they are used to group SQL operations. However, I didn’t fully understand how databases manage multiple transactions, maintain consistency during concurrent execution, or recover from crashes.  

Terms like **ACID**, **concurrency control**, and **recovery algorithms** seemed abstract to me. I didn’t realize how much effort goes into ensuring that databases behave correctly, even during system failures, power outages, or user errors.

---

## Key Takeaways from Unit 7
---

### Lesson 18: Transactions & ACID Properties
- A **transaction** is a logical unit of work that must either complete fully or not at all.
- Transactions must satisfy **ACID** properties:
  - **Atomicity**: All or nothing.
  - **Consistency**: Transforms the database from one valid state to another.
  - **Isolation**: Concurrent transactions shouldn’t interfere with each other.
  - **Durability**: Once committed, changes persist even after a crash.
- Learned how transactions are implemented in SQL and how durability and atomicity depend on stable storage and logging.

### Lesson 19: Concurrency Control
- Concurrency control prevents issues when multiple transactions run simultaneously.
- **Locks** are used to control access to data:
  - **Shared (S)**: for reading.
  - **Exclusive (X)**: for writing.
- **Two-Phase Locking (2PL)** ensures serializability:
  - **Growing phase**: locks are acquired.
  - **Shrinking phase**: locks are released.
- **Deadlocks** can occur when transactions wait for each other’s locks. Handled through:
  - **Detection** (e.g., waits-for graph).
  - **Prevention** (e.g., wait-die or wound-wait protocols).
- Locking can occur at different **granularities**: attribute, row, page, table.
- **Intention locks** signal intent to lock finer-grained data (e.g., IS, IX, SIX).

### Lesson 20: Recovery Techniques
- Databases use **log-based recovery** to undo or redo changes:
  - Log records: `<Ti, Xj, old_value, new_value>`
  - Undo: Restore old values.
  - Redo: Reapply new values.
- **Checkpoints** speed up recovery by limiting how much log data needs to be processed.
- Recovery algorithms:
  - **ARIES**: Advanced method with 3 steps: analysis, redo, undo.
- **Write-Ahead Logging (WAL)** ensures logs are written before data changes.
- **Fuzzy checkpoints** allow updates during checkpointing.
- **Remote backups** and **replication** ensure high availability in disaster recovery.
- Recovery also applies to **main-memory databases**, with some optimizations.

---

## What I Learned and Why It Matters
---
I learned that transactions are not just groupings of SQL commands—they’re critical for **data integrity**, especially when many users or systems interact with the same database.  

Concurrency control is essential to avoid anomalies like lost updates or dirty reads. Locks and serialization techniques ensure the database remains consistent.  

Recovery mechanisms provide the safety net that **ensures durability and atomicity**, even if the system crashes. Without them, every failure could mean permanent data loss.  

Understanding ARIES and WAL showed me how databases **trace back and restore** their state intelligently without requiring full restarts or full backups every time.

These concepts aren't just theoretical—they’re used in real-world systems that **power banking, e-commerce, and critical infrastructure**.

---

## Personal Growth and Reflection
---
Before this unit, I never thought deeply about what would happen if a database crashed in the middle of an update, or how it handles multiple users updating the same data.  

This unit made me realize that **reliability in databases is not automatic—it’s engineered** through a combination of protocols, logs, and clever scheduling.  

I also appreciated learning about **deadlock resolution** and how systems choose a victim to rollback—something I hadn’t considered before.  

Understanding recovery made me see how robust modern databases are and gave me more confidence to work with **real-world applications** that rely on fault tolerance and high availability.

---

## Including My Work from Class
---

### Lesson 18
- Practiced writing PostgreSQL transactions using `BEGIN`, `COMMIT`, and `ROLLBACK`.
- Explored ACID properties through account transfer examples.

### Lesson 19
- Created examples of shared and exclusive locks.
- Simulated deadlocks and resolved them using waits-for graphs and prevention algorithms.
- Learned intention locks and lock escalation.

### Lesson 20
- Implemented logging and recovery scenarios using undo/redo examples.
- Analyzed checkpointing and fuzzy checkpointing behavior.
- Studied ARIES algorithm step-by-step and wrote SQL lock statements (`FOR SHARE`, `FOR UPDATE`).

---

## Das Ende (The End)
